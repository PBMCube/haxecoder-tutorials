<html><head><style>body{font-family:Arial, Helvetica, sans-serif; padding:20px;}pre{ background:#eee; padding:20px; }footer{color:#666; border-top:1px solid #666; margin-top:20px; padding-top:20px; width:100%;}</style><title>45. HaxeFlixel RPG tutorial: Part 8</title></head><body><h1>45. HaxeFlixel RPG tutorial: Part 8</h1><h3>2014-10-16</h3><img alt="HaxeFlixel RPG tutorial collision" class="thumb" src="img/92.png">
<p>Today we'll add collectible potions that replenish the player's health when picked up.</p>
<p>The player will be able to pick up an item by walking over it. This means collision detection.</p>
<p>So far we actually have no collision detection whatsoever. The "collision" with the walls we have right now is not actual collision, but avoidance, since we use a pathfinding algorithm to move our character.</p>
<p>Let's start by creating a new FlxSprite subclass called Potion.</p><p>Create a new class called Potion.hx:</p>
<pre><code class="haxe">package ;
import flixel.FlxSprite;

class Potion extends FlxSprite
{

	public function new() 
	{
		super();
		loadGraphic(&quot;assets/images/potion.png&quot;, false, 16, 16);
	}
	
}</code></pre>
<p>This is the graphic I'm using:</p>
<img alt="HaxeFlixel RPG tutorial collision" class="center" src="img/94.png">
<p>Now back to PlayState.hx, introduce a new variable.</p>
<pre><code class="haxe">private var potions:FlxTypedGroup&lt;Potion&gt;;</code></pre>
<p>This FlxTypedGroup instance will allow us to group all potions together to create a common entry point for collision detection. Instantiate this object in the init() function and add it to the state:</p>
<pre><code class="haxe">potions = new FlxTypedGroup&lt;Potion&gt;();
add(potions);
</code></pre>
<p>Then call spawnPotion() a few times to create a few collectible potions.</p>
<pre><code class="haxe">spawnPotion(5, 5);
spawnPotion(6, 5);
spawnPotion(3, 10);
spawnPotion(4, 10);
spawnPotion(1, 10);
</code></pre>
<p>The spawnPotion() function creates a Potion instance, adds it to the group, and positions it according to the parameter values:</p>
<pre><code class="haxe">private function spawnPotion(x:Int, y:Int):Void{
	var potion:Potion = new Potion();
	potion.x = x * TILE_WIDTH;
	potion.y = y * TILE_HEIGHT;
	potions.add(potion);
}
</code></pre>
<p>Since all of our potions are bundled together in a group, we only need to add 1 line to the update() function to handle collision between the hero and all potions in this group.</p>
<pre><code class="haxe">// Collisions
FlxG.overlap(hero, potions, onPotionCollision);
</code></pre>
<p>The first two parameters represent the objects or groups being tested, the third parameter is the callback function to call when a collision is detected.</p>
<p>Here's the code to the collision handler:</p>
<pre><code class="haxe">private function onPotionCollision(hero:FlxSprite, potion:Potion):Void {
	if (potion.exists &amp;&amp; hero.exists) {
		potion.kill();
		addHealth(1);
	}
}
</code></pre>
<p>You can see that I first check whether both of these entities exist, using their "exists" property. This value is set to false when I call the kill() method of a sprite. The same method also removes the sprite from the screen.</p>
<p>The addHealth() method adds health and updates the text field:</p>
<pre><code class="haxe">public function addHealth(num:Int):Void {
	health += num;
	if (health &gt; maxHealth) {
		health = maxHealth;
	}
	updateHealth();
}</code></pre>
<p>Since our map is bigger than the screen, we need to expand the world bounds to support collision on all of the map's area. Add this to the init() function:</p>
<pre><code class="haxe">FlxG.worldBounds.width = TILE_WIDTH * LEVEL_WIDTH;
FlxG.worldBounds.height = TILE_HEIGHT * LEVEL_HEIGHT;</code></pre>
<p>Now here's the full code to PlayState.hx:</p>
<pre><code class="haxe">package ;

import flixel.FlxCamera;
import flixel.FlxG;
import flixel.FlxObject;
import flixel.FlxSprite;
import flixel.FlxState;
import flixel.group.FlxGroup;
import flixel.group.FlxSpriteGroup;
import flixel.group.FlxTypedGroup;
import flixel.text.FlxText;
import flixel.tile.FlxTilemap;
import flixel.util.FlxColor;
import flixel.util.FlxPath;
import flixel.util.FlxPoint;
import openfl.Assets;

/**
 * A FlxState which can be used for the actual gameplay.
 */
class PlayState extends FlxState
{
	private var tileMap:FlxTilemap;
	public static var TILE_WIDTH:Int = 16;
	public static var TILE_HEIGHT:Int = 16;
	public static var LEVEL_WIDTH:Int = 50;
	public static var LEVEL_HEIGHT:Int = 50;
	public static var CAMERA_SPEED:Int = 8;
	private var camera:FlxCamera;
	private var cameraFocus:FlxSprite;
	private var movementMarker:FlxSprite;
	private var hero:FlxSprite;
	private var path:FlxPath;
	
	private var overlay:FlxSpriteGroup;
	private var healthDisplay:FlxText;
	private var health:Int;
	private var maxHealth:Int;
	private var potions:FlxTypedGroup&lt;Potion&gt;;
	/**
	 * Function that is called up when to state is created to set it up.
	 */
	override public function create():Void
	{
		super.create();

		FlxG.worldBounds.width = TILE_WIDTH * LEVEL_WIDTH;
		FlxG.worldBounds.height = TILE_HEIGHT * LEVEL_HEIGHT;
		
		tileMap = new FlxTilemap();
		tileMap.loadMap(Assets.getText(&quot;assets/data/map.csv&quot;), &quot;assets/images/tileset.png&quot;, TILE_WIDTH, TILE_HEIGHT, 0, 1);
		tileMap.setTileProperties(0, FlxObject.ANY);
		tileMap.setTileProperties(1, FlxObject.ANY);
		tileMap.setTileProperties(2, FlxObject.NONE);
		add(tileMap);
		
		cameraFocus = new FlxSprite();
		cameraFocus.makeGraphic(1, 1, FlxColor.TRANSPARENT);
		add(cameraFocus);
		
		camera = FlxG.camera;
		camera.follow(cameraFocus, FlxCamera.STYLE_LOCKON);
		
		movementMarker = new FlxSprite();
		movementMarker.visible = false;
		add(movementMarker);
		
		hero = new FlxSprite(16, 16);
		hero.loadGraphic(&quot;assets/images/hero.png&quot;, true, 16, 16);
		hero.animation.add(&quot;down&quot;, [0, 1, 0, 2]);
		hero.animation.add(&quot;up&quot;, [3, 4, 3, 5]);
		hero.animation.add(&quot;right&quot;, [6, 7, 6, 8]);
		hero.animation.add(&quot;left&quot;, [9, 10, 9, 11]);
		add(hero);
		
		potions = new FlxTypedGroup&lt;Potion&gt;();
		add(potions);
		spawnPotion(5, 5);
		spawnPotion(6, 5);
		spawnPotion(3, 10);
		spawnPotion(4, 10);
		spawnPotion(1, 10);
		
		hero.animation.play(&quot;down&quot;);
		
		path = new FlxPath();
		
		healthDisplay = new FlxText(2, 2);
		health = 5;
		maxHealth = 10;
		updateHealth();
		
		overlay = new FlxSpriteGroup();
		overlay.add(healthDisplay);
		overlay.scrollFactor.x = 0;
		overlay.scrollFactor.y = 0;
		add(overlay);
	}
	
	private function spawnPotion(x:Int, y:Int):Void{
		var potion:Potion = new Potion();
		potion.x = x * TILE_WIDTH;
		potion.y = y * TILE_HEIGHT;
		potions.add(potion);
	}
	
	private function onPotionCollision(hero:FlxSprite, potion:Potion):Void {
		if (potion.exists &amp;&amp; hero.exists) {
			potion.kill();
			addHealth(1);
		}
	}
	
	public function updateHealth():Void {
		healthDisplay.text = &quot;Health: &quot; + health + &quot;/&quot; + maxHealth;
	}
	
	public function addHealth(num:Int):Void {
		health += num;
		if (health &gt; maxHealth) {
			health = maxHealth;
		}
		updateHealth();
	}

	/**
	 * Function that is called when this state is destroyed - you might want to
	 * consider setting all objects this state uses to null to help garbage collection.
	 */
	override public function destroy():Void
	{
		super.destroy();
	}

	/**
	 * Function that is called once every frame.
	 */
	override public function update():Void
	{
		super.update();
		
		// Collisions
		FlxG.overlap(hero, potions, onPotionCollision);
		
		// Animation
		if (!path.finished &amp;&amp; path.nodes!=null) {
			if (path.angle == 0 || path.angle == 45 || path.angle == -45) {
				hero.animation.play(&quot;up&quot;);
			}
			if (path.angle == 180 || path.angle == -135 || path.angle == 135) {
				hero.animation.play(&quot;down&quot;);
			}
			if (path.angle == 90) {
				hero.animation.play(&quot;right&quot;);
			}
			if (path.angle == -90) {
				hero.animation.play(&quot;left&quot;);
			}
		} else {
			hero.animation.curAnim.curFrame = 0;
			hero.animation.curAnim.stop();
		}
		
		// Camera movement
		if (FlxG.keys.anyPressed([&quot;DOWN&quot;, &quot;S&quot;])) {
			cameraFocus.y += CAMERA_SPEED;
		}
		if (FlxG.keys.anyPressed([&quot;UP&quot;, &quot;W&quot;])) {
			cameraFocus.y -= CAMERA_SPEED;
		}
		if (FlxG.keys.anyPressed([&quot;RIGHT&quot;, &quot;D&quot;])) {
			cameraFocus.x += CAMERA_SPEED;
		}
		if (FlxG.keys.anyPressed([&quot;LEFT&quot;, &quot;A&quot;])) {
			cameraFocus.x -= CAMERA_SPEED;
		}
		
		// Camera bounds
		if (cameraFocus.x &lt; FlxG.width / 2) {
			cameraFocus.x = FlxG.width / 2;
		}
		if (cameraFocus.x &gt; LEVEL_WIDTH * TILE_WIDTH - FlxG.width / 2) {
			cameraFocus.x = LEVEL_WIDTH * TILE_WIDTH - FlxG.width / 2;
		}
		if (cameraFocus.y &lt; FlxG.height / 2) {
			cameraFocus.y = FlxG.height / 2;
		}
		if (cameraFocus.y &gt; LEVEL_HEIGHT * TILE_HEIGHT - FlxG.height / 2) {
			cameraFocus.y = LEVEL_HEIGHT * TILE_HEIGHT - FlxG.height / 2;
		}
		
		// Mouse clicks
		if (FlxG.mouse.justReleased){
			var tileCoordX:Int = Math.floor(FlxG.mouse.x / TILE_WIDTH);
			var tileCoordY:Int = Math.floor(FlxG.mouse.y / TILE_HEIGHT);
			
			movementMarker.visible = true;
			if (tileMap.getTile(tileCoordX, tileCoordY) == 2) {
				var nodes:Array&lt;FlxPoint&gt; = tileMap.findPath(FlxPoint.get(hero.x + TILE_WIDTH/2, hero.y + TILE_HEIGHT/2), FlxPoint.get(tileCoordX * TILE_WIDTH + TILE_WIDTH/2, tileCoordY * TILE_HEIGHT + TILE_HEIGHT/2));
				if (nodes != null) {
					path.start(hero, nodes);
					movementMarker.loadGraphic(AssetPaths.marker_move__png, false, 16, 16);
				}else {
					movementMarker.loadGraphic(AssetPaths.marker_stop__png, false, 16, 16);
				}
			}else {
				movementMarker.loadGraphic(AssetPaths.marker_stop__png, false, 16, 16);
			}
			movementMarker.setPosition(tileCoordX * TILE_WIDTH, tileCoordY * TILE_HEIGHT);
		}
	}
}</code></pre>
<p>As the result, you'll be able to pick up potions by walking over them:</p>
<img alt="HaxeFlixel RPG tutorial collision" class="center" src="img/93.gif">
<p>We'll <a href="46_haxeflixel_rpg_tutorial_part_9.html">add a separate HUD with a level counter and an experience bar in the next tutorial</a>!</p><footer>&copy; Kirill Poletaev</footer></body></html>